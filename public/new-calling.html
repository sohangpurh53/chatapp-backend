<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App - WebRTC Calling Test Interface</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            padding: 20px;
            min-height: 600px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .panel h3 {
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #007bff;
        }

        .auth-section {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        input,
        select,
        button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .call-button {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            margin: 5px 0;
        }

        .video-call-button {
            background: linear-gradient(135deg, #007bff 0%, #6610f2 100%);
        }

        .end-call-button {
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: 600;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.calling {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .user-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            margin: 10px 0;
        }

        .user-item {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .user-item:hover {
            background-color: #e9ecef;
        }

        .user-item.selected {
            background-color: #007bff;
            color: white;
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            background: white;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            background: #f8f9fa;
        }

        .message.own {
            background: #007bff;
            color: white;
            margin-left: 20px;
        }

        .message.other {
            background: #e9ecef;
            margin-right: 20px;
        }

        .logs {
            height: 300px;
            overflow-y: auto;
            background: #212529;
            color: #28a745;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
        }

        .call-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .call-controls.active {
            display: grid;
        }

        .incoming-call {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
        }

        .incoming-call.show {
            display: block;
        }

        .caller-info {
            margin-bottom: 20px;
        }

        .caller-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            margin: 0 auto 10px;
        }

        .call-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .answer-btn {
            background: #28a745;
            border: none;
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
        }

        .decline-btn {
            background: #dc3545;
            border: none;
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Video call interface */
        .video-call-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
        }

        .video-call-overlay.active {
            display: flex;
            flex-direction: column;
        }

        .video-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #remoteVideo {
            width: 100%;
            max-width: 1200px;
            height: auto;
            max-height: 80vh;
            background: #000;
            border-radius: 10px;
        }

        #localVideo {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 250px;
            height: 180px;
            background: #000;
            border-radius: 10px;
            border: 3px solid white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .video-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
        }

        .video-control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .video-control-btn:hover {
            transform: scale(1.1);
        }

        .video-control-btn.mute {
            background: #28a745;
        }

        .video-control-btn.mute.active {
            background: #dc3545;
        }

        .video-control-btn.video {
            background: #007bff;
        }

        .video-control-btn.video.active {
            background: #6c757d;
        }

        .video-control-btn.end {
            background: #dc3545;
            width: 70px;
            height: 70px;
        }

        .call-info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
        }

        .connection-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .connection-status.connected {
            background: #28a745;
        }

        .connection-status.connecting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            #localVideo {
                width: 150px;
                height: 110px;
                bottom: 20px;
                right: 20px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üìû Chat App - WebRTC Calling Test Interface</h1>
            <p>Test voice calls, video calls, user search, and real-time chat with WebRTC</p>
        </div>

        <div class="main-content">
            <!-- Authentication & Connection Panel -->
            <div class="panel">
                <h3>üîê Authentication & Connection</h3>

                <div class="auth-section">
                    <div class="form-group">
                        <label>Email:</label>
                        <input type="email" id="email" value="test@example.com">
                    </div>
                    <div class="form-group">
                        <label>Password:</label>
                        <input type="password" id="password" value="password123">
                    </div>
                    <div class="form-group">
                        <label>Username (for registration):</label>
                        <input type="text" id="username" value="testuser">
                    </div>
                    <button onclick="login()">Login</button>
                    <button onclick="register()">Register</button>
                    <button onclick="createTestUsers()" style="background: #17a2b8;">Create Test Users</button>
                </div>

                <div id="connectionStatus" class="status disconnected">
                    Disconnected
                </div>

                <button onclick="connectSocket()" id="connectBtn" disabled>Connect to Socket</button>
                <button onclick="disconnectSocket()" id="disconnectBtn" disabled>Disconnect</button>
            </div>

            <!-- User Search & Chat Panel -->
            <div class="panel">
                <h3>üë• Users & Chat</h3>

                <div class="form-group">
                    <label>Search Users:</label>
                    <input type="text" id="searchInput" placeholder="Search by username or email (min 2 chars)"
                        oninput="debounceSearch()">
                    <div style="display: flex; gap: 5px; margin-top: 5px;">
                        <button onclick="searchUsers()" style="flex: 1;">üîç Search</button>
                        <button onclick="loadAllUsers()" style="flex: 1; background: #28a745;">üë• Load All</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <small style="color: #6c757d;">Quick search:</small><br>
                        <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                            <button onclick="quickSearch('alice')" style="font-size: 11px; padding: 5px;">alice</button>
                            <button onclick="quickSearch('bob')" style="font-size: 11px; padding: 5px;">bob</button>
                            <button onclick="quickSearch('test')" style="font-size: 11px; padding: 5px;">test</button>
                            <button onclick="quickSearch('user')" style="font-size: 11px; padding: 5px;">user</button>
                        </div>
                    </div>
                </div>

                <div id="userList" class="user-list">
                    <!-- Users will be populated here -->
                </div>

                <div class="form-group">
                    <label>Selected User:</label>
                    <input type="text" id="selectedUser" readonly placeholder="Select a user to chat/call">
                </div>

                <div id="chatMessages" class="chat-messages">
                    <!-- Chat messages will appear here -->
                </div>

                <div class="form-group">
                    <input type="text" id="messageInput" placeholder="Type a message..."
                        onkeypress="handleMessageKeyPress(event)">
                    <button onclick="sendMessage()">Send Message</button>
                </div>
            </div>

            <!-- Calling Panel -->
            <div class="panel">
                <h3>üìû Calling Features</h3>

                <div id="callingInstructions"
                    style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 12px;">
                    <strong>üìã To make calls:</strong><br>
                    1. Connect to Socket (left panel)<br>
                    2. Search & select a user (above)<br>
                    3. Click call buttons below
                </div>

                <div class="form-group">
                    <button class="call-button" onclick="initiateVoiceCall()" id="voiceCallBtn" disabled>
                        üìû Start Voice Call
                    </button>
                    <button class="video-call-button" onclick="initiateVideoCall()" id="videoCallBtn" disabled>
                        üìπ Start Video Call
                    </button>
                </div>

                <div id="callStatus" class="status" style="display: none;">
                    No active call
                </div>

                <div id="callControls" class="call-controls">
                    <button onclick="toggleAudio()" id="audioBtn">üîá Mute</button>
                    <button onclick="toggleVideo()" id="videoBtn">üìπ Video</button>
                    <button class="end-call-button" onclick="endCall()">üìû End Call</button>
                </div>

                <div class="form-group">
                    <h4>WebRTC Status</h4>
                    <div id="webrtcStatus"
                        style="padding: 10px; background: white; border-radius: 5px; font-size: 12px;">
                        <div>Connection State: <span id="connectionState">New</span></div>
                        <div>ICE State: <span id="iceState">New</span></div>
                        <div>Signaling State: <span id="signalingState">Stable</span></div>
                    </div>
                </div>

                <div class="form-group">
                    <h4>Audio Test</h4>
                    <button onclick="testMicrophone()" style="background: #17a2b8; margin: 2px;">üé§ Test Mic</button>
                    <button onclick="testSpeakers()" style="background: #17a2b8; margin: 2px;">üîä Test Speakers</button>
                    <div id="audioTestResult"
                        style="font-size: 12px; margin-top: 5px; padding: 5px; background: #f8f9fa; border-radius: 3px;">
                        Click buttons to test audio devices
                    </div>
                </div>

                <div class="form-group">
                    <h4>Call History</h4>
                    <div id="callHistory"
                        style="max-height: 100px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px;">
                        <!-- Call history will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-top: 20px;">
            <div class="logs" id="logs">
                <strong>üìã Activity Logs</strong><br>
                Ready to start testing...<br>
            </div>

            <div
                style="background: #212529; color: #28a745; padding: 15px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 12px; height: 300px; overflow-y: auto;">
                <strong>üîä Audio Debug Info</strong><br>
                <div id="audioDebugInfo">
                    <div>Local Audio: <span id="localAudioStatus">Not initialized</span></div>
                    <div>Remote Audio: <span id="remoteAudioStatus">Not connected</span></div>
                    <div>Audio Elements: <span id="audioElementsStatus">Not created</span></div>
                    <div>WebRTC Audio: <span id="webrtcAudioStatus">Not started</span></div>
                    <br>
                    <button onclick="refreshAudioDebug()"
                        style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 3px; font-size: 11px; margin: 2px;">Refresh
                        Debug</button>
                    <button onclick="fixAudioIssues()"
                        style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; font-size: 11px; margin: 2px;">Fix
                        Audio</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Incoming Call Overlay -->
    <div id="incomingCall" class="incoming-call">
        <div class="caller-info">
            <div class="caller-avatar" id="callerAvatar">?</div>
            <h3 id="callerName">Unknown Caller</h3>
            <p id="callType">Voice Call</p>
        </div>
        <div class="call-actions">
            <button class="answer-btn" onclick="answerCall()">üìû Answer</button>
            <button class="decline-btn" onclick="declineCall()">‚ùå Decline</button>
        </div>
    </div>

    <!-- Video Call Overlay -->
    <div id="videoCallOverlay" class="video-call-overlay">
        <div class="call-info">
            <h3><span class="connection-status connecting" id="connectionIndicator"></span><span
                    id="callParticipant">Connecting...</span></h3>
            <div id="callDuration">00:00</div>
        </div>
        <div class="video-container">
            <video id="remoteVideo" autoplay playsinline></video>
            <video id="localVideo" autoplay playsinline muted></video>
        </div>
        <div class="video-controls">
            <button class="video-control-btn mute" id="videoAudioBtn" onclick="toggleAudioInCall()">üé§</button>
            <button class="video-control-btn end" onclick="endCall()">üìû</button>
            <button class="video-control-btn video" id="videoVideoBtn" onclick="toggleVideoInCall()">üìπ</button>
        </div>
    </div>

    <!-- Hidden audio elements for voice calls -->
    <audio id="remoteAudio" autoplay style="display: none;"></audio>
    <audio id="localAudioFeedback" muted style="display: none;"></audio>

    <script>
        let socket = null;
        let authToken = null;
        let currentUser = null;
        let selectedUserId = null;
        let currentChatId = null;
        let currentCall = null;
        let users = [];
        let searchTimeout = null;

        // WebRTC variables
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let isAudioMuted = false;
        let isVideoMuted = false;
        let callStartTime = null;
        let callDurationInterval = null;

        // ICE servers configuration
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        function getBaseURL(fullUrl) {
            const urlObj = new URL(fullUrl);
            return `${urlObj.protocol}//${urlObj.host}`;
        }
        const url = window.location.href;
        const baseUrl = getBaseURL(url);
        console.log(baseUrl);

        // Utility functions
        function log(message) {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            logs.innerHTML += `[${timestamp}] ${message}<br>`;
            logs.scrollTop = logs.scrollHeight;
        }

        function updateConnectionStatus(status, message) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `status ${status}`;
            statusEl.textContent = message;
        }

        // Debounce search function
        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const query = document.getElementById('searchInput').value.trim();
                if (query.length >= 2 || query.length === 0) {
                    searchUsers();
                }
            }, 500);
        }

        // Create test users for easier testing
        async function createTestUsers() {
            const testUsers = [
                { username: 'alice', email: 'alice@test.com', password: 'password123' },
                { username: 'bob', email: 'bob@test.com', password: 'password123' },
                { username: 'charlie', email: 'charlie@test.com', password: 'password123' },
                { username: 'diana', email: 'diana@test.com', password: 'password123' },
                { username: 'jamie', email: 'jamie@test.com', password: 'password123' }
            ];

            log('üîß Creating test users...');
            let created = 0;

            for (const user of testUsers) {
                try {
                    const response = await fetch(baseUrl + '/api/auth/register', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(user)
                    });

                    if (response.ok) {
                        created++;
                        log(`‚úÖ Created user: ${user.username}`);
                    } else {
                        const data = await response.json();
                        if (data.message && data.message.includes('already exists')) {
                            log(`‚ÑπÔ∏è User ${user.username} already exists`);
                        } else {
                            log(`‚ö†Ô∏è Failed to create ${user.username}: ${data.message}`);
                        }
                    }
                } catch (error) {
                    log(`‚ùå Error creating ${user.username}: ${error.message}`);
                }
            }

            log(`üéâ Test user creation complete! ${created} new users created.`);
            log('üí° You can now search for: alice, bob, charlie, diana, jamie');

            setTimeout(() => {
                document.getElementById('searchInput').value = 'test';
                searchUsers();
            }, 1000);
        }

        // Authentication functions
        async function register() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const username = document.getElementById('username').value;

            try {
                const response = await fetch(baseUrl + '/api/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ email, password, username })
                });

                const data = await response.json();

                if (response.ok) {
                    authToken = data.token;
                    currentUser = data.user;
                    log(`‚úÖ Registration successful: ${data.user.username}`);
                    document.getElementById('connectBtn').disabled = false;
                } else {
                    log(`‚ùå Registration failed: ${data.message}`);
                }
            } catch (error) {
                log(`‚ùå Registration error: ${error.message}`);
            }
        }

        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;

            try {
                const response = await fetch(baseUrl + '/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();

                if (response.ok) {
                    authToken = data.token;
                    currentUser = data.user;
                    log(`‚úÖ Login successful: ${data.user.username}`);
                    document.getElementById('connectBtn').disabled = false;
                } else {
                    log(`‚ùå Login failed: ${data.message}`);
                }
            } catch (error) {
                log(`‚ùå Login error: ${error.message}`);
            }
        }

        // Socket connection functions
        function connectSocket() {
            if (!authToken) {
                log('‚ùå Please login first');
                return;
            }

            socket = io(baseUrl, {
                auth: {
                    token: authToken
                },
                transports: ['websocket', 'polling']
            });

            setupSocketListeners();

            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
        }

        function disconnectSocket() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }

            updateConnectionStatus('disconnected', 'Disconnected');
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            document.getElementById('voiceCallBtn').disabled = true;
            document.getElementById('videoCallBtn').disabled = true;
        }

        function setupSocketListeners() {
            socket.on('connect', () => {
                log(`‚úÖ Connected to socket server. Socket ID: ${socket.id}`);
                updateConnectionStatus('connected', `Connected as ${currentUser.username}`);

                if (selectedUserId) {
                    document.getElementById('voiceCallBtn').disabled = false;
                    document.getElementById('videoCallBtn').disabled = false;
                    document.getElementById('callingInstructions').style.display = 'none';
                }

                log('üí° Use "Create Test Users" button or search for users to start testing');
            });

            socket.on('connect_error', (error) => {
                log(`‚ùå Connection error: ${error.message}`);
                updateConnectionStatus('disconnected', 'Connection failed');
            });

            socket.on('disconnect', () => {
                log('üîå Disconnected from socket server');
                updateConnectionStatus('disconnected', 'Disconnected');
            });

            socket.on('new_message', (message) => {
                log(`üì® New message from ${message.sender.username}: ${message.content}`);
                displayMessage(message);
            });

            socket.on('user_typing', (data) => {
                log(`‚å®Ô∏è ${data.username} is typing...`);
            });

            socket.on('incoming_call', async (callData) => {
                log(`üìû Incoming ${callData.callType} call from ${callData.caller.username}`);
                currentCall = callData;
                showIncomingCall(callData);
            });

            socket.on('call_answered', async (callData) => {
                log(`‚úÖ Call answered by receiver`);
                currentCall = { ...currentCall, ...callData };

                updateCallStatus('connected', 'Call connected');
                showCallControls(true);

                // Show video overlay if video call and we are the caller
                if (currentCall.callType === 'video' && currentCall.callerId === currentUser.id) {
                    document.getElementById('videoCallOverlay').classList.add('active');
                    const participantName = users.find(u => u.id === currentCall.receiverId)?.username || 'User';
                    document.getElementById('callParticipant').textContent = participantName;
                }

                // Create offer if we initiated the call
                if (currentCall.callerId === currentUser.id) {
                    await createOffer(currentCall.callType);
                }
            });

            socket.on('call_initiated', (callData) => {
                log(`üìû Call initiated successfully`);
                currentCall = { ...currentCall, ...callData };
                updateCallStatus('calling', 'Ringing...');
            });

            socket.on('call_connected', async (callData) => {
                log(`‚úÖ Call connected`);
                updateCallStatus('connected', 'Call connected');
                showCallControls(true);
            });

            socket.on('call_declined', (callData) => {
                log(`‚ùå Call declined`);
                updateCallStatus('', 'Call declined');
                showCallControls(false);
                closeVideoCall();
                currentCall = null;
            });

            socket.on('call_missed', (callData) => {
                log(`üìû Call missed`);
                updateCallStatus('', 'Call missed - no answer');
                showCallControls(false);
                closeVideoCall();
                currentCall = null;
            });

            socket.on('call_ended', (callData) => {
                log(`üìû Call ended. Reason: ${callData.reason || 'Unknown'}`);
                updateCallStatus('', 'Call ended');
                showCallControls(false);
                hideIncomingCall();
                closeVideoCall();

                if (currentCall) {
                    addToCallHistory({
                        ...currentCall,
                        endReason: callData.reason,
                        endedBy: callData.endedBy
                    });
                }

                currentCall = null;
            });

            socket.on('call_signal', async (signalData) => {
                log(`üîÑ Received WebRTC signal: ${signalData.type}`);
                await handleSignaling(signalData);
            });

            socket.on('user_status_changed', (data) => {
                log(`üë§ ${data.username} is now ${data.isOnline ? 'online' : 'offline'}`);
                updateUserStatus(data.userId, data.isOnline);
            });

            socket.on('call_error', (error) => {
                log(`‚ùå Call error: ${error.message}`);
                updateCallStatus('', `Call failed: ${error.message}`);
                showCallControls(false);
                closeVideoCall();
                currentCall = null;
            });

            socket.on('error', (error) => {
                log(`‚ùå Socket error: ${error.message}`);
            });
        }

        // WebRTC Functions
        async function initializePeerConnection(callType) {
            try {
                // Create peer connection
                peerConnection = new RTCPeerConnection(iceServers);

                // Set up event handlers
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate && currentCall) {
                        log('üßä Sending ICE candidate');
                        const targetUserId = currentCall.callerId === currentUser.id ? currentCall.receiverId : currentCall.callerId;
                        socket.emit('call_signal', {
                            callId: currentCall.callId || currentCall.id,
                            targetUserId: targetUserId,
                            signal: {
                                type: 'ice-candidate',
                                candidate: event.candidate
                            }
                        });
                    }
                };

                peerConnection.ontrack = (event) => {
                    log(`üì∫ Received remote ${event.track.kind} track`);

                    if (event.streams && event.streams[0]) {
                        remoteStream = event.streams[0];

                        if (currentCall.callType === 'video') {
                            const remoteVideo = document.getElementById('remoteVideo');
                            if (remoteVideo.srcObject !== event.streams[0]) {
                                remoteVideo.srcObject = event.streams[0];
                                log('‚úÖ Remote video stream attached');
                            }
                        } else {
                            // For voice calls, create an audio element
                            let remoteAudio = document.getElementById('remoteAudio');
                            if (!remoteAudio) {
                                remoteAudio = document.createElement('audio');
                                remoteAudio.id = 'remoteAudio';
                                remoteAudio.autoplay = true;
                                remoteAudio.controls = false;
                                remoteAudio.style.display = 'none';
                                document.body.appendChild(remoteAudio);
                                log('‚úÖ Created remote audio element');
                            }

                            if (remoteAudio.srcObject !== event.streams[0]) {
                                remoteAudio.srcObject = event.streams[0];
                                log('‚úÖ Remote audio stream attached');
                            }
                        }
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    log(`üîó Connection state: ${peerConnection.connectionState}`);
                    document.getElementById('connectionState').textContent = peerConnection.connectionState;

                    const indicator = document.getElementById('connectionIndicator');
                    if (peerConnection.connectionState === 'connected') {
                        indicator.className = 'connection-status connected';
                        startCallDuration();

                        // Test audio when connected
                        testAudioConnection();
                    } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                        indicator.className = 'connection-status connecting';
                        log('‚ö†Ô∏è Connection lost or failed');
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    log(`üßä ICE state: ${peerConnection.iceConnectionState}`);
                    document.getElementById('iceState').textContent = peerConnection.iceConnectionState;
                };

                peerConnection.onsignalingstatechange = () => {
                    log(`üì° Signaling state: ${peerConnection.signalingState}`);
                    document.getElementById('signalingState').textContent = peerConnection.signalingState;
                };

                // Get user media with enhanced audio constraints
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100,
                        channelCount: 2
                    },
                    video: callType === 'video' ? {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    } : false
                };

                log(`üéØ Requesting media with constraints: ${JSON.stringify(constraints)}`);

                localStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Verify we got the expected tracks
                 const audioTracks = localStream.getAudioTracks();
                 const videoTracks = localStream.getVideoTracks();

                if (audioTracks.length === 0) {
                    throw new Error('No audio track obtained from getUserMedia');
                }

                if (callType === 'video' && videoTracks.length === 0) {
                    log('‚ö†Ô∏è No video track obtained, falling back to audio only');
                }

                // Add tracks to peer connection
                localStream.getTracks().forEach(track => {
                    const sender = peerConnection.addTrack(track, localStream);
                    log(`‚ûï Added ${track.kind} track to peer connection: ${track.label}`);
                    log(`   Track settings: ${JSON.stringify(track.getSettings())}`);
                });

                // Display local media
                if (callType === 'video') {
                    const localVideo = document.getElementById('localVideo');
                    localVideo.srcObject = localStream;
                    log('‚úÖ Local video stream attached');
                } else {
                    // For voice calls, we still need to handle local audio feedback
                    log('‚úÖ Local audio stream initialized (no visual element needed)');
                }

                // Test audio tracks
                //const audioTracks = localStream.getAudioTracks();
                //const videoTracks = localStream.getVideoTracks();
                log(`üìä Local stream: ${audioTracks.length} audio tracks, ${videoTracks.length} video tracks`);

                audioTracks.forEach((track, index) => {
                    log(`üé§ Audio track ${index}: ${track.label}, enabled: ${track.enabled}`);
                });

                videoTracks.forEach((track, index) => {
                    log(`üìπ Video track ${index}: ${track.label}, enabled: ${track.enabled}`);
                });

                log('‚úÖ Peer connection initialized successfully');
                return true;
            } catch (error) {
                log(`‚ùå Error initializing peer connection: ${error.message}`);
                alert(`Failed to access camera/microphone: ${error.message}`);
                return false;
            }
        }

        async function createOffer(callType) {
            try {
                const initialized = await initializePeerConnection(callType);
                if (!initialized) return;

                log('üìù Creating offer...');

                // Create offer with proper constraints for audio
                const offerOptions = {
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: callType === 'video'
                };

                const offer = await peerConnection.createOffer(offerOptions);
                await peerConnection.setLocalDescription(offer);

                const targetUserId = currentCall.receiverId || currentCall.receiver?.id;
                socket.emit('call_signal', {
                    callId: currentCall.callId || currentCall.id,
                    targetUserId: targetUserId,
                    signal: {
                        type: 'offer',
                        sdp: offer.sdp
                    }
                });

                log('‚úÖ Offer created and sent');
            } catch (error) {
                log(`‚ùå Error creating offer: ${error.message}`);
            }
        }

        async function createAnswer(callType) {
            try {
                // Only initialize if not already done
                if (!peerConnection) {
                    const initialized = await initializePeerConnection(callType);
                    if (!initialized) return;
                }

                log('üìù Creating answer...');
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                const targetUserId = currentCall.callerId || currentCall.caller?.id;
                socket.emit('call_signal', {
                    callId: currentCall.callId || currentCall.id,
                    targetUserId: targetUserId,
                    signal: {
                        type: 'answer',
                        sdp: answer.sdp
                    }
                });

                log('‚úÖ Answer created and sent');
            } catch (error) {
                log(`‚ùå Error creating answer: ${error.message}`);
            }
        }

        async function handleSignaling(signalData) {
            try {
                const signal = signalData.signal;

                if (signal.type === 'offer') {
                    log('üì• Received offer, setting remote description...');

                    // Initialize peer connection if not already done
                    if (!peerConnection) {
                        const initialized = await initializePeerConnection(currentCall.callType);
                        if (!initialized) {
                            log('‚ùå Failed to initialize peer connection');
                            return;
                        }
                    }

                    // Set remote description first
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription({
                            type: 'offer',
                            sdp: signal.sdp
                        })
                    );

                    log('‚úÖ Remote description set, now creating answer...');

                    // Now create the answer
                    const answerOptions = {
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: currentCall.callType === 'video'
                    };

                    const answer = await peerConnection.createAnswer(answerOptions);
                    await peerConnection.setLocalDescription(answer);

                    const targetUserId = signalData.fromUserId;
                    socket.emit('call_signal', {
                        callId: currentCall.callId || currentCall.id,
                        targetUserId: targetUserId,
                        signal: {
                            type: 'answer',
                            sdp: answer.sdp
                        }
                    });

                    log('‚úÖ Answer created and sent');

                } else if (signal.type === 'answer') {
                    log('üì• Received answer, setting remote description...');

                    if (!peerConnection) {
                        log('‚ùå No peer connection available');
                        return;
                    }

                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription({
                            type: 'answer',
                            sdp: signal.sdp
                        })
                    );

                    log('‚úÖ Remote description set successfully');

                } else if (signal.type === 'ice-candidate') {
                    log('üì• Received ICE candidate');

                    if (peerConnection && peerConnection.remoteDescription && signal.candidate) {
                        try {
                            await peerConnection.addIceCandidate(
                                new RTCIceCandidate(signal.candidate)
                            );
                            log('‚úÖ ICE candidate added');
                        } catch (e) {
                            log(`‚ö†Ô∏è Error adding ICE candidate: ${e.message}`);
                        }
                    } else {
                        log('‚ö†Ô∏è Cannot add ICE candidate - no remote description yet');
                    }
                }
            } catch (error) {
                log(`‚ùå Error handling signaling: ${error.message}`);
            }
        }

        function startCallDuration() {
            callStartTime = Date.now();
            callDurationInterval = setInterval(() => {
                const duration = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
                const seconds = (duration % 60).toString().padStart(2, '0');
                document.getElementById('callDuration').textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopCallDuration() {
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
                callDurationInterval = null;
            }
            callStartTime = null;
        }

        function testAudioConnection() {
            log('üîä Testing audio connection...');

            // Test local audio
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                audioTracks.forEach((track, index) => {
                    log(`üé§ Local audio track ${index}: enabled=${track.enabled}, muted=${track.muted}, readyState=${track.readyState}`);
                });
            }

            // Test remote audio
            if (remoteStream) {
                const audioTracks = remoteStream.getAudioTracks();
                audioTracks.forEach((track, index) => {
                    log(`üîä Remote audio track ${index}: enabled=${track.enabled}, muted=${track.muted}, readyState=${track.readyState}`);
                });

                // Ensure remote audio element is properly configured
                const remoteAudio = document.getElementById('remoteAudio');
                if (remoteAudio && currentCall.callType === 'voice') {
                    remoteAudio.volume = 1.0;
                    remoteAudio.muted = false;

                    // Force play if paused
                    if (remoteAudio.paused) {
                        remoteAudio.play().catch(e => log(`‚ö†Ô∏è Could not play remote audio: ${e.message}`));
                    }

                    log(`üîä Remote audio element: volume=${remoteAudio.volume}, muted=${remoteAudio.muted}, paused=${remoteAudio.paused}`);
                }

                const remoteVideo = document.getElementById('remoteVideo');
                if (remoteVideo && currentCall.callType === 'video') {
                    remoteVideo.volume = 1.0;
                    remoteVideo.muted = false;

                    // Force play if paused
                    if (remoteVideo.paused) {
                        remoteVideo.play().catch(e => log(`‚ö†Ô∏è Could not play remote video: ${e.message}`));
                    }

                    log(`üì∫ Remote video element: volume=${remoteVideo.volume}, muted=${remoteVideo.muted}, paused=${remoteVideo.paused}`);
                }
            }

            // Update debug panel
            refreshAudioDebug();
        }

        function closeVideoCall() {
            // Stop all tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    log(`‚èπÔ∏è Stopped ${track.kind} track`);
                });
                localStream = null;
            }

            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                log('üîå Peer connection closed');
            }

            // Reset video elements
            const localVideo = document.getElementById('localVideo');
            const remoteVideo = document.getElementById('remoteVideo');
            const remoteAudio = document.getElementById('remoteAudio');

            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            if (remoteAudio) {
                remoteAudio.srcObject = null;
            }

            // Hide video overlay
            document.getElementById('videoCallOverlay').classList.remove('active');

            // Reset states
            isAudioMuted = false;
            isVideoMuted = false;
            stopCallDuration();

            // Reset WebRTC status
            document.getElementById('connectionState').textContent = 'New';
            document.getElementById('iceState').textContent = 'New';
            document.getElementById('signalingState').textContent = 'Stable';
        }

        // User search functions
        async function searchUsers() {
            const query = document.getElementById('searchInput').value.trim();

            if (!authToken) {
                log('‚ùå Please login first');
                return;
            }

            if (query.length > 0 && query.length < 2) {
                log('‚ö†Ô∏è Search query must be at least 2 characters');
                return;
            }

            if (query.length === 0) {
                log('‚ö†Ô∏è Please enter a search query or use "Load All" button');
                return;
            }

            try {
                log(`üîç Searching for users: "${query}"`);

                const response = await fetch(baseUrl + `/api/chat/search/users?query=${encodeURIComponent(query)}`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    users = data.users || [];
                    displayUsers(users);
                    log(`‚úÖ Found ${users.length} users for "${query}"`);
                } else {
                    log(`‚ùå Search failed: ${data.error || data.message}`);
                    users = [];
                    displayUsers(users);
                }
            } catch (error) {
                log(`‚ùå Search error: ${error.message}`);
                users = [];
                displayUsers(users);
            }
        }

        async function loadAllUsers() {
            if (!authToken) {
                log('‚ùå Please login first');
                return;
            }

            try {
                log('üë• Loading all users...');

                const searchQueries = ['te', 'us', 'ad', 'ja', 'bo', 'al', 'ch', 'di'];
                let allUsers = [];

                for (const query of searchQueries) {
                    try {
                        const response = await fetch(baseUrl + `/api/chat/search/users?query=${encodeURIComponent(query)}`, {
                            headers: {
                                'Authorization': `Bearer ${authToken}`
                            }
                        });

                        const data = await response.json();

                        if (response.ok && data.users) {
                            log(`‚úÖ Found ${data.users.length} users for pattern "${query}"`);
                            data.users.forEach(user => {
                                if (!allUsers.find(u => u.id === user.id)) {
                                    allUsers.push(user);
                                }
                            });
                        } else {
                            log(`‚ö†Ô∏è Search for "${query}" failed: ${data.error || data.message || 'Unknown error'}`);
                        }
                    } catch (error) {
                        log(`‚ùå Search for "${query}" error: ${error.message}`);
                    }
                }

                users = allUsers;
                displayUsers(users);
                log(`‚úÖ Loaded ${users.length} total users`);

                if (users.length === 0) {
                    log('üí° No users found. Try creating test users first!');
                }
            } catch (error) {
                log(`‚ùå Error loading users: ${error.message}`);
                users = [];
                displayUsers(users);
            }
        }

        async function quickSearch(searchTerm) {
            document.getElementById('searchInput').value = searchTerm;
            await searchUsers();
        }

        function displayUsers(userList) {
            const userListEl = document.getElementById('userList');
            userListEl.innerHTML = '';

            if (userList.length === 0) {
                userListEl.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #6c757d;">
                        <p>No users found</p>
                        <small>Try creating test users or searching with different terms</small>
                    </div>
                `;
                return;
            }

            userList.forEach(user => {
                if (user.id === currentUser?.id) return;

                const userEl = document.createElement('div');
                userEl.className = 'user-item';
                userEl.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${user.username}</strong><br>
                            <small style="color: #6c757d;">${user.email}</small>
                        </div>
                        <div style="text-align: right;">
                            <span style="color: ${user.isOnline ? 'green' : 'gray'}; font-size: 12px;">
                                ${user.isOnline ? 'üü¢ Online' : '‚ö´ Offline'}
                            </span><br>
                            <small style="color: #007bff; cursor: pointer;">Click to select</small>
                        </div>
                    </div>
                `;
                userEl.onclick = () => selectUser(user);
                userListEl.appendChild(userEl);
            });

            log(`üìã Displaying ${userList.length} users (excluding yourself)`);
        }

        function selectUser(user) {
            selectedUserId = user.id;
            document.getElementById('selectedUser').value = `${user.username} (${user.email})`;

            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));
            event.target.closest('.user-item').classList.add('selected');

            if (socket && socket.connected) {
                document.getElementById('voiceCallBtn').disabled = false;
                document.getElementById('videoCallBtn').disabled = false;
                document.getElementById('callingInstructions').style.display = 'none';
            } else {
                log('‚ö†Ô∏è Connect to socket first to enable calling');
                document.getElementById('voiceCallBtn').disabled = true;
                document.getElementById('videoCallBtn').disabled = true;
            }

            log(`üë§ Selected user: ${user.username}`);
            createDirectChat(user.id);
        }

        function updateUserStatus(userId, isOnline) {
            const userItems = document.querySelectorAll('.user-item');
            userItems.forEach(item => {
                const statusSpan = item.querySelector('span');
                if (statusSpan) {
                    statusSpan.innerHTML = isOnline ? 'üü¢ Online' : '‚ö´ Offline';
                    statusSpan.style.color = isOnline ? 'green' : 'gray';
                }
            });
        }

        // Chat functions
        async function createDirectChat(participantId) {
            try {
                const response = await fetch(baseUrl + '/api/chat/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        participantIds: [participantId],
                        isGroup: false
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    currentChatId = data.chat.id;
                    log(`üí¨ Chat created/found: ${data.chat.id}`);

                    if (socket) {
                        socket.emit('join_chat', { chatId: currentChatId });
                    }

                    loadChatMessages(currentChatId);
                } else {
                    log(`‚ùå Chat creation failed: ${data.message}`);
                }
            } catch (error) {
                log(`‚ùå Chat creation error: ${error.message}`);
            }
        }

        async function loadChatMessages(chatId) {
            try {
                const response = await fetch(baseUrl + `/api/chat/${chatId}/messages`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const messagesEl = document.getElementById('chatMessages');
                    messagesEl.innerHTML = '';

                    data.messages.forEach(message => {
                        displayMessage(message);
                    });

                    log(`üì® Loaded ${data.messages.length} messages`);
                } else {
                    log(`‚ùå Failed to load messages: ${data.message}`);
                }
            } catch (error) {
                log(`‚ùå Message loading error: ${error.message}`);
            }
        }

        function displayMessage(message) {
            const messagesEl = document.getElementById('chatMessages');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${message.senderId === currentUser.id ? 'own' : 'other'}`;

            const timestamp = new Date(message.createdAt).toLocaleTimeString();
            messageEl.innerHTML = `
                <strong>${message.sender.username}</strong> <small>${timestamp}</small><br>
                ${message.content}
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const content = messageInput.value.trim();

            if (!content || !currentChatId || !socket) return;

            socket.emit('send_message', {
                chatId: currentChatId,
                content: content,
                messageType: 'text'
            });

            messageInput.value = '';
            log(`üì§ Sent message: ${content}`);
        }

        function handleMessageKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Calling functions
        function initiateVoiceCall() {
            if (!socket || !socket.connected) {
                log('‚ùå Please connect to socket first');
                return;
            }
            if (!selectedUserId) {
                log('‚ùå Please select a user first');
                return;
            }

            const callData = {
                receiverId: selectedUserId,
                callType: 'voice',
                chatId: currentChatId
            };

            socket.emit('initiate_call', callData);
            log(`üìû Initiating voice call to user ${selectedUserId}`);

            // Store temporary call data
            currentCall = {
                ...callData,
                callerId: currentUser.id,
                status: 'calling'
            };

            updateCallStatus('calling', 'Calling...');
        }

        function initiateVideoCall() {
            if (!socket || !socket.connected) {
                log('‚ùå Please connect to socket first');
                return;
            }
            if (!selectedUserId) {
                log('‚ùå Please select a user first');
                return;
            }

            const callData = {
                receiverId: selectedUserId,
                callType: 'video',
                chatId: currentChatId
            };

            socket.emit('initiate_call', callData);
            log(`üìπ Initiating video call to user ${selectedUserId}`);

            // Store temporary call data
            currentCall = {
                ...callData,
                callerId: currentUser.id,
                status: 'calling'
            };

            updateCallStatus('calling', 'Video calling...');

            // Show video overlay for caller
            document.getElementById('videoCallOverlay').classList.add('active');
            const participantName = users.find(u => u.id === selectedUserId)?.username || 'User';
            document.getElementById('callParticipant').textContent = `Calling ${participantName}...`;
        }

        async function answerCall() {
            if (!currentCall || !socket) return;

            const callId = currentCall.callId || currentCall.id;
            socket.emit('answer_call', { callId: callId });
            log(`‚úÖ Answering call ${callId}`);

            hideIncomingCall();
            updateCallStatus('connecting', 'Connecting...');
            showCallControls(true);

            // Show video overlay if video call
            if (currentCall.callType === 'video') {
                document.getElementById('videoCallOverlay').classList.add('active');
                document.getElementById('callParticipant').textContent = currentCall.caller.username;
            }

            // Initialize peer connection (answer will be created when offer is received)
            await initializePeerConnection(currentCall.callType);
        }

        function declineCall() {
            if (!currentCall || !socket) return;

            const callId = currentCall.callId || currentCall.id;
            socket.emit('decline_call', { callId: callId });
            log(`‚ùå Declining call ${callId}`);

            hideIncomingCall();
            currentCall = null;
        }

        function endCall() {
            if (!currentCall || !socket) return;

            const callId = currentCall.callId || currentCall.id;
            socket.emit('end_call', { callId: callId });
            log(`üìû Ending call ${callId}`);

            updateCallStatus('', 'Call ended');
            showCallControls(false);
            hideIncomingCall();
            closeVideoCall();
            currentCall = null;
        }

        function toggleAudio() {
            if (!currentCall || !socket) return;

            socket.emit('toggle_audio', { callId: currentCall.callId });
            log(`üîá Toggled audio for call ${currentCall.callId}`);

            const btn = document.getElementById('audioBtn');
            btn.textContent = btn.textContent.includes('Mute') ? 'üîä Unmute' : 'üîá Mute';
        }

        function toggleVideo() {
            if (!currentCall || !socket) return;

            socket.emit('toggle_video', { callId: currentCall.callId });
            log(`üìπ Toggled video for call ${currentCall.callId}`);

            const btn = document.getElementById('videoBtn');
            btn.textContent = btn.textContent.includes('Video') ? 'üìπ Video Off' : 'üìπ Video';
        }

        function toggleAudioInCall() {
            if (!localStream) return;

            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                isAudioMuted = !audioTrack.enabled;

                const btn = document.getElementById('videoAudioBtn');
                btn.className = isAudioMuted ? 'video-control-btn mute active' : 'video-control-btn mute';
                btn.textContent = isAudioMuted ? 'üîá' : 'üé§';

                log(isAudioMuted ? 'üîá Audio muted' : 'üé§ Audio unmuted');
            }
        }

        function toggleVideoInCall() {
            if (!localStream) return;

            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                isVideoMuted = !videoTrack.enabled;

                const btn = document.getElementById('videoVideoBtn');
                btn.className = isVideoMuted ? 'video-control-btn video active' : 'video-control-btn video';
                btn.textContent = isVideoMuted ? 'üìπ' : 'üìπ';

                log(isVideoMuted ? 'üìπ Video disabled' : 'üìπ Video enabled');
            }
        }

        // UI helper functions
        function updateCallStatus(status, message) {
            const statusEl = document.getElementById('callStatus');
            statusEl.style.display = message ? 'block' : 'none';
            statusEl.className = `status ${status}`;
            statusEl.textContent = message;
        }

        function showCallControls(show) {
            const controlsEl = document.getElementById('callControls');
            controlsEl.className = show ? 'call-controls active' : 'call-controls';
        }

        function showIncomingCall(callData) {
            currentCall = callData;

            document.getElementById('callerName').textContent = callData.caller.username;
            document.getElementById('callType').textContent = `${callData.callType.charAt(0).toUpperCase() + callData.callType.slice(1)} Call`;
            document.getElementById('callerAvatar').textContent = callData.caller.username.charAt(0).toUpperCase();

            document.getElementById('incomingCall').classList.add('show');
        }

        function hideIncomingCall() {
            document.getElementById('incomingCall').classList.remove('show');
        }

        function addToCallHistory(callData) {
            const historyEl = document.getElementById('callHistory');
            const callEl = document.createElement('div');
            callEl.style.cssText = 'padding: 5px; border-bottom: 1px solid #eee; font-size: 12px;';

            const timestamp = new Date().toLocaleTimeString();
            const type = callData.callType || 'voice';

            // Determine participant name
            let participant = 'Unknown';
            if (callData.callerId === currentUser.id) {
                // We were the caller
                participant = users.find(u => u.id === callData.receiverId)?.username || 'Unknown';
            } else {
                // We were the receiver
                participant = callData.caller?.username || users.find(u => u.id === callData.callerId)?.username || 'Unknown';
            }

            const status = callData.endReason || 'completed';
            const statusIcon = status === 'declined' ? '‚ùå' : status === 'missed' ? 'üìû' : '‚úÖ';

            callEl.innerHTML = `
                <strong>${statusIcon} ${type} call</strong> with ${participant}<br>
                <small>Status: ${status} | ${timestamp}</small>
            `;

            historyEl.insertBefore(callEl, historyEl.firstChild);
        }

        // Audio fix function
        function fixAudioIssues() {
            log('üîß Attempting to fix audio issues...');

            try {
                // Fix remote audio element
                const remoteAudio = document.getElementById('remoteAudio');
                if (remoteAudio && remoteStream) {
                    remoteAudio.srcObject = remoteStream;
                    remoteAudio.volume = 1.0;
                    remoteAudio.muted = false;
                    remoteAudio.autoplay = true;

                    remoteAudio.play().then(() => {
                        log('‚úÖ Remote audio element fixed and playing');
                    }).catch(e => {
                        log(`‚ö†Ô∏è Could not play remote audio: ${e.message}`);
                    });
                }

                // Fix remote video element
                const remoteVideo = document.getElementById('remoteVideo');
                if (remoteVideo && remoteStream) {
                    remoteVideo.srcObject = remoteStream;
                    remoteVideo.volume = 1.0;
                    remoteVideo.muted = false;
                    remoteVideo.autoplay = true;

                    remoteVideo.play().then(() => {
                        log('‚úÖ Remote video element fixed and playing');
                    }).catch(e => {
                        log(`‚ö†Ô∏è Could not play remote video: ${e.message}`);
                    });
                }

                // Unmute all audio tracks
                if (remoteStream) {
                    remoteStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                        log(`üîä Enabled remote audio track: ${track.label}`);
                    });
                }

                if (localStream) {
                    localStream.getAudioTracks().forEach(track => {
                        if (track.muted) {
                            track.enabled = true;
                            log(`üé§ Enabled local audio track: ${track.label}`);
                        }
                    });
                }

                refreshAudioDebug();
                log('‚úÖ Audio fix attempt completed');

            } catch (error) {
                log(`‚ùå Error fixing audio: ${error.message}`);
            }
        }

        // Audio debugging function
        function refreshAudioDebug() {
            const localAudioStatus = document.getElementById('localAudioStatus');
            const remoteAudioStatus = document.getElementById('remoteAudioStatus');
            const audioElementsStatus = document.getElementById('audioElementsStatus');
            const webrtcAudioStatus = document.getElementById('webrtcAudioStatus');

            // Check local audio
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    localAudioStatus.innerHTML = `‚úÖ Active<br>&nbsp;&nbsp;Label: ${track.label}<br>&nbsp;&nbsp;Enabled: ${track.enabled}<br>&nbsp;&nbsp;Muted: ${track.muted}`;
                } else {
                    localAudioStatus.textContent = '‚ùå No audio tracks';
                }
            } else {
                localAudioStatus.textContent = '‚ùå No local stream';
            }

            // Check remote audio
            if (remoteStream) {
                const audioTracks = remoteStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    remoteAudioStatus.innerHTML = `‚úÖ Connected<br>&nbsp;&nbsp;Label: ${track.label}<br>&nbsp;&nbsp;Enabled: ${track.enabled}<br>&nbsp;&nbsp;Muted: ${track.muted}`;
                } else {
                    remoteAudioStatus.textContent = '‚ùå No remote audio tracks';
                }
            } else {
                remoteAudioStatus.textContent = '‚ùå No remote stream';
            }

            // Check audio elements
            const remoteAudio = document.getElementById('remoteAudio');
            const remoteVideo = document.getElementById('remoteVideo');

            let elementsInfo = '';
            if (remoteAudio) {
                elementsInfo += `Audio: vol=${remoteAudio.volume}, muted=${remoteAudio.muted}<br>`;
            }
            if (remoteVideo) {
                elementsInfo += `Video: vol=${remoteVideo.volume}, muted=${remoteVideo.muted}`;
            }
            audioElementsStatus.innerHTML = elementsInfo || 'No elements found';

            // Check WebRTC status
            if (peerConnection) {
                webrtcAudioStatus.innerHTML = `‚úÖ Active<br>&nbsp;&nbsp;State: ${peerConnection.connectionState}<br>&nbsp;&nbsp;ICE: ${peerConnection.iceConnectionState}`;
            } else {
                webrtcAudioStatus.textContent = '‚ùå No peer connection';
            }
        }

        // Audio testing functions
        async function testMicrophone() {
            try {
                log('üé§ Testing microphone...');
                const testResult = document.getElementById('audioTestResult');
                testResult.textContent = 'Testing microphone...';

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    testResult.innerHTML = `‚úÖ Microphone working<br>Device: ${track.label}<br>Enabled: ${track.enabled}`;
                    log(`‚úÖ Microphone test passed: ${track.label}`);

                    // Stop the test stream
                    setTimeout(() => {
                        stream.getTracks().forEach(track => track.stop());
                    }, 2000);
                } else {
                    testResult.textContent = '‚ùå No microphone found';
                    log('‚ùå No microphone tracks found');
                }
            } catch (error) {
                const testResult = document.getElementById('audioTestResult');
                testResult.textContent = `‚ùå Microphone test failed: ${error.message}`;
                log(`‚ùå Microphone test failed: ${error.message}`);
            }
        }

        async function testSpeakers() {
            try {
                log('üîä Testing speakers...');
                const testResult = document.getElementById('audioTestResult');
                testResult.textContent = 'Testing speakers...';

                // Create a test audio element
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';

                audio.volume = 0.1; // Low volume for test

                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        testResult.textContent = '‚úÖ Speakers working - you should hear a brief tone';
                        log('‚úÖ Speaker test: audio playing');

                        setTimeout(() => {
                            audio.pause();
                            audio.currentTime = 0;
                        }, 1000);
                    }).catch(error => {
                        testResult.textContent = `‚ùå Speaker test failed: ${error.message}`;
                        log(`‚ùå Speaker test failed: ${error.message}`);
                    });
                }
            } catch (error) {
                const testResult = document.getElementById('audioTestResult');
                testResult.textContent = `‚ùå Speaker test failed: ${error.message}`;
                log(`‚ùå Speaker test failed: ${error.message}`);
            }
        }

        // Function availability check
        function checkFunctions() {
            const functions = ['login', 'register', 'searchUsers', 'loadAllUsers', 'testMicrophone', 'testSpeakers', 'debounceSearch'];
            const missing = [];
            
            functions.forEach(funcName => {
                if (typeof window[funcName] !== 'function') {
                    missing.push(funcName);
                }
            });
            
            if (missing.length > 0) {
                log(`‚ùå Missing functions: ${missing.join(', ')}`);
                console.error('Missing functions:', missing);
            } else {
                log('‚úÖ All functions are properly defined');
            }
        }

        // Ensure functions are globally accessible
        window.login = login;
        window.register = register;
        window.searchUsers = searchUsers;
        window.loadAllUsers = loadAllUsers;
        window.testMicrophone = testMicrophone;
        window.testSpeakers = testSpeakers;
        window.debounceSearch = debounceSearch;
        window.quickSearch = quickSearch;
        window.createTestUsers = createTestUsers;
        window.connectSocket = connectSocket;
        window.disconnectSocket = disconnectSocket;
        window.sendMessage = sendMessage;
        window.handleMessageKeyPress = handleMessageKeyPress;
        window.initiateVoiceCall = initiateVoiceCall;
        window.initiateVideoCall = initiateVideoCall;
        window.answerCall = answerCall;
        window.declineCall = declineCall;
        window.endCall = endCall;
        window.toggleAudio = toggleAudio;
        window.toggleVideo = toggleVideo;
        window.toggleAudioInCall = toggleAudioInCall;
        window.toggleVideoInCall = toggleVideoInCall;
        window.refreshAudioDebug = refreshAudioDebug;
        window.fixAudioIssues = fixAudioIssues;

        // Initialize
        log('üöÄ Chat App WebRTC Calling Test Interface loaded');
        checkFunctions();
        log('üìã Instructions:');
        log('1. Login or Register with credentials');
        log('2. Connect to Socket.IO server');
        log('3. Test your audio devices using the Audio Test buttons');
        log('4. Search and select a user');
        log('5. Start voice or video calls');
        log('6. Test chat messaging');
        log('üí° WebRTC will request camera/microphone permissions when you make a call');
    </script>
</body>

</html>